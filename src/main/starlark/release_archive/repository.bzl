load("@bazel_tools//tools/build_defs/repo:http.bzl", "http_archive")
load("@bazel_tools//tools/build_defs/repo:utils.bzl", "maybe")

versions = struct(
    RULES_KOTLIN = struct(
        urls = [
            "https://github.com/bazelbuild/rules_kotlin/archive/v1.6.0.zip",
        ],
        sha256 = "",
        prefix = "rules_kotlin-1.6.0",
    ),
    RULES_KOTLIN_HEAD = struct(
        urls = [
            "https://github.com/bazelbuild/rules_kotlin/archive/refs/heads/master.zip",
        ],
        sha256 = "cd5388f019d856ede82dd2a3dc7cf935d4925340fee56094f1e23d93a62b5439",
        prefix = "rules_kotlin-master",
    ),
)

def archive_repository_implementation(repository_ctx):
    attr = repository_ctx.attr

    # not OS safe. Presuming linux-likes until complaints.
    release_archive = attr.local_release_archive_target

    # move to execroot, then reference local repo.
    workspace = repository_ctx.path("../../%s" % release_archive.workspace_root)

    if not workspace.exists:
        fail("local workspace %s does not exist" % workspace)

    target = "//%s:%s" % (release_archive.package, release_archive.name)

    workspace_file = workspace.get_child("WORKSPACE")

    # if kt_download_local_dev_dependencies isn't there, the WORKSPACE file is invalid
    # probably generated by http_archive.
    if not ("kt_download_local_dev_dependencies" in repository_ctx.read(workspace_file)):
        repository_ctx.report_progress(
            "Symlinking WORKSPACE to WORKSPACE.dev.bazel in %s" % (workspace.basename),
        )

        # Remove existing WORKSPACE, as it might be created by http_archive
        repository_ctx.delete(workspace_file)

        # Symlink the WORKSPACE
        repository_ctx.symlink(
            workspace.get_child("WORKSPACE.dev.bazel"),
            workspace_file,
        )
    repository_ctx.report_progress(
        "Building %s in %s... (may take a while.)" % (target, workspace.basename),
    )

    result = repository_ctx.execute(
        [
            "bazel",
            "build",
            target,
        ],
        working_directory = str(workspace),
        timeout = 1200,  # builds can take a minute. Or ten.
    )

    if result.return_code:
        fail("%s: %s\n%s\n\nenv:%s" % (str(workspace), result.stderr, result.stdout, repository_ctx.os.environ))
    release_artifact = workspace.get_child("bazel-bin")
    if release_archive.package:
        release_artifact = release_artifact.get_child(release_archive.package)
    release_artifact = release_artifact.get_child(release_archive.name + ".tgz")

    repository_ctx.extract(
        archive = release_artifact,
    )

    # Update the timestamp on the repository rule source to ensure it's always re-evaluated.
    # This appears to cause issues on windows with permissions -- so don't do it.
    if not "win" in repository_ctx.os.name:
        self = workspace
        for segment in "src/main/starlark/release_archive/repository.bzl".split("/"):
            self = self.get_child(segment)
        repository_ctx.execute([
            "touch",
            str(self),
        ])

_archive_repository = repository_rule(
    implementation = archive_repository_implementation,
    local = True,
    configure = True,
    attrs = {
        "local_release_archive_target": attr.label(
            doc = "release_archive rule.",
        ),
    },
)

def archive_repository(
        name,
        local_path = "../..",
        release_archive_target = Label("//:rules_kotlin_release"),
        remote_source_archive = None,
        source_repository_name = None):
    """
    archive_repository builds rules_kotlin from either a local_path or a remote archive.

    Args:
        name: of the repository
        local_path: to an un-archived rules_kotlin repository. Defaults to '../..'.
        release_archive_target: Label to build a rules_kotlin release
        remote_source_archive: struct(
            urls = list of urls for a remote source archive,
            sha256 = hash of remote archive,
            prefix = directory string to strip from extracted archive
        )
        source_repository_name: of the release archive. Defaults to `name`_head. If set to an existing
          repository no new repository will be created.
    """
    source_repository_name = source_repository_name or ("%s_head" % name)
    if remote_source_archive:
        maybe(
            http_archive,
            name = source_repository_name,
            sha256 = remote_source_archive.sha256,
            strip_prefix = remote_source_archive.prefix,
            urls = remote_source_archive.urls,
        )
    else:
        maybe(
            native.local_repository,
            name = source_repository_name,
            path = local_path,
        )
    _archive_repository(
        name = name,
        local_release_archive_target = "@%s//%s:%s" % (
            source_repository_name,
            release_archive_target.package,
            release_archive_target.name,
        ),
    )
